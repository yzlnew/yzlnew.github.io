<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>频繁模式挖掘 - 黄石的时空回环</title><link rel=icon type=image/png href=/img/favicon.png><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="频繁模式挖掘"><meta itemprop=description content=" 信息"><meta itemprop=datePublished content="2021-03-23T00:00:00+00:00"><meta itemprop=dateModified content="2021-03-23T00:00:00+00:00"><meta itemprop=wordCount content="2603"><meta itemprop=keywords content="算法,Fim"><meta property="og:url" content="https://yzlnew.com/2021/03/frequent-itemset-mining/"><meta property="og:site_name" content="黄石的时空回环"><meta property="og:title" content="频繁模式挖掘"><meta property="og:description" content=" 信息"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-03-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-23T00:00:00+00:00"><meta property="article:tag" content="算法"><meta property="article:tag" content="Fim"><meta name=twitter:card content="summary"><meta name=twitter:title content="频繁模式挖掘"><meta name=twitter:description content=" 信息"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yzlnew.com/css/main.css><link rel=stylesheet type=text/css href=https://yzlnew.com/css/custom.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yzlnew.com/css/dark.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yzlnew.com/css/custom_dark.css><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://yzlnew.com/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yzlnew.com/><img src=/img/avatar.png alt=黄石的时空回环></a></div><h1 class=site-title><a href=https://yzlnew.com/>黄石的时空回环</a></h1><div class=site-description><p>Let me fly to the 🌕️</p></div><nav class=nav><ul class=flat><li><a href=/>主页</a></li><li><a href=/about>关于我</a></li><li><a href=/tags>标签</a></li></ul></nav></div><div class=sidebar><h4>文章目录</h4><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#fpm-算法>FPM 算法</a><ul><li><a href=#定义>定义</a></li><li><a href=#join-based-算法>Join-Based 算法</a></li><li><a href=#tree-based-算法>Tree-Based 算法</a></li><li><a href=#基于后缀的递归算法>基于后缀的递归算法</a></li><li><a href=#其他优化方法>其他优化方法</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div><div class=post><article><div class=post-header><div class=matter><h1 class=title>频繁模式挖掘</h1><div class=meta><span class=date>2021-03-23</span><div class=tags><ul class=flat><li><a href=/tags/%E7%AE%97%E6%B3%95>算法</a></li><li><a href=/tags/fim>fim</a></li></ul></div></div></div></div></article><div class=markdown><style type=text/css>.notice{padding:18px;line-height:24px;margin-bottom:24px;margin-top:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:#efafa9}.notice.warning{background:#fcefee}.notice.info .notice-title{background:#ffe999}.notice.info{background:#fffbeb}.notice.note .notice-title{background:#99d6ff}.notice.note{background:#ebf7ff}.notice.tip .notice-title{background:#ccd9bf}.notice.tip{background:#f5f7f2}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:.125em;position:relative}</style><svg width="0" height="0" display="none"><symbol id="tip-notice" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check-circle"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></symbol><symbol id="note-notice" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-alert-circle"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></symbol><symbol id="warning-notice" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-alert-triangle"><path d="M10.29 3.86 1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42.0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></symbol><symbol id="info-notice" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></symbol></svg><div class="notice info"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#info-notice"/></svg></span>信息</p><p>注意，本文主要是来源 1 第二章的中文翻译。</p></div><p>在数据挖掘领域，频繁模式挖掘（Frequent pattern mining）在算法发展过程中是最被广泛深入研究的问题之一。其中诞生了非常多的算法，最常见的是基于支持度（Support）的方法，即找到出现频率大于阈值的项目集（Itemset）。但是这些项目集不能很好刻画用户对于某个项目的兴趣，因此还有基于兴趣的方法。这里只介绍基于支持度的方法。</p><h3 id=基本概念>基本概念</h3><p>频繁模式挖掘的问题根据可以描述为<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><pre><code>给定一个数据库 D，其中有 T1 ...TN 的交易记录
找出所有至少出现了占比超过 s 的模式 P
</code></pre><p>即找到数据集中至少出现一定次数或比例（叫做支持度）的模式。这个问题最初是起源于超市购物中经常组合购买的商品。</p><p>频繁模式挖掘也被称作是关联规则挖掘<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。不过关联规则是定义在频繁模式之上的。规则 $U \Rightarrow V$ 可以被称作是支持度 s 和可信度 c 的关联规则，必须满足以下条件：</p><ol><li>$U \cup V$ 是频繁模式</li><li>$U \cup V$ 的支持度除以 $U$ 的支持度大于等于 c</li></ol><p>通俗来说，就是频繁模式中，这个规则有一定的发生的可能性。因为第一步寻找频繁模式通常是比较有挑战性的，因此主要的研究领域都集中在这里。</p><p>另外相关问题有时序模式的挖掘。比如购买商品会有一个时间戳，与购买习惯有关。</p><p>一些频繁模式挖掘的应用如下：</p><ul><li>客户交易分析（调整策略、推荐商品）</li><li>网页数据挖掘</li><li>软件 Bug 分析</li><li>化学和生物分析</li></ul><p>频繁模式挖掘的研究主要有四个方面：</p><ul><li>更高效的算法</li><li>算法的可扩展性</li><li>更复杂的数据类型</li><li>应用研究</li></ul><h3 id=fpm-算法>FPM 算法</h3><p>传统的 FPM 是基于支持度的，算法的原型可以描述成</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>提示</p><p><strong>FPM 算法原型</strong><br><strong>输入</strong>：数据库 D，最小支持度 s<br><strong>输出</strong>：FP<br>初始化频繁模式集合 FP={}<br>在 FP 中插入长度为 1 的频繁模式<br>重复<br>->从 FP 中生成一个候选模式 P<br>->if P 在 D 中的支持度 >= s<br>&mdash;>把 P 加入 FP<br>直到 FP 中所有频繁模式都被遍历</p></div><p>可以看到 FPM 算法的搜索空间是非常大的，和数据集的大小成指数关系。</p><p>几乎所有的 FPM 算法都可以看作这个原型算法复杂的变种。一些最早的算法是基于连接的，比如原始的 Apriori 算法，它其实也可以看作是对枚举树的一种广度优先遍历。之后的一些算法是基于树的枚举，认为候选模式组成了词典树，并通过广度优先或者深度优先来遍历，如 TreeProjection 算法。枚举树是定义在频繁集的前缀上的，再之后的一些算法如 FP-growth 是基于后缀递归探索搜索空间的。</p><h4 id=定义>定义</h4><ol><li>数据集 T
: $T = {T_1,T_2,\cdots,T_n}$，其中 $T_i = {x_1,x_2,\cdots,x_l}$，即数据集中有若干交易记录，每笔记录是物品的集合。</li><li>物品集 P
: $P \subseteq T_i$，物品集的大小定义为包含的物品的数量。</li><li>P 的支持度
: 包括 P 的交易的数量。</li><li>频繁集
: 若 P 的支持度不小于设定的标准，则 P 是频繁的。</li></ol><h4 id=join-based-算法>Join-Based 算法</h4><p>Join-Based 的算法通过连接的方式从频繁的 k-patterns 来产生 k+1 的候选。</p><h5 id=apriori>Apriori</h5><p>基本的想法是频繁模式的任一子集都是频繁的。那么可以通过连接的方式从长度为 k 的频繁模式中产生长度为 k+1 的频繁模式候选。</p><p>Join 连接有 k-1 个元素相同的长度为 k 的频繁模式对。</p><p>举例来说，如果 ${i_1,i_2,i_3}$ 和 ${i_1,i_2,i_4}$ 都是频繁的，那么 ${i_1,i_2,i_3,i_4}$ 也可能是频繁的。因此就可以生成一个候选模式。</p><p>为了防止生成候选的重复，规定只连接前 k-1 个元素相同的集合。</p><p>同时，值得注意的是部分候选项是可以直接被排除的，根据前面的基本想法，比如 ${i_1,i_3,i_4}$ 不是频繁的，那么之前所得到的候选可以直接被排除，不用进一步的验证。</p><p>那么整个算法的过程可以描述成</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>提示</p><p><strong>Apriori</strong> 算法<br><strong>输入</strong>：数据库 $T$，支持度 $s$<br><strong>输出</strong>：所有 $F_i$ 的合集<br>用特殊的方法产生长度 1 和 2 的频繁集 $F_1,F_2$<br>$k:=2$<br>当 $F_k$ 非空时<br>->通过连接从 $F_k$ 中产生 $k+1$ 的候选集 $C_{k+1}$<br>->通过子集验证的方法排除一些候选模式<br>->计算候选集中的支持度来产生 $F_{k+1}$<br>->$k:=k+i$</p></div><p>在算法循环中，计算开销最大的是计算候选集中的支持度。因此有很多优化的方法和数据结构（比如哈希树）来加速这个过程。</p><h5 id=apriori-优化>Apriori 优化</h5><ol><li>AprioriTid: 在第 k 步的时候把每个记录替换成短或空的记录，从而使得子集支持度的计算更高效。但是有时会因为多个候选是记录的子集导致的额外计算开销。</li><li>AprioriHybrid: 初始迭代的时候不使用 AprioriTid。</li></ol><h5 id=dhp-算法3>DHP 算法<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></h5><p>两个优化方向：</p><ol><li>每次迭代的时候修剪候选集。在前一轮计算的时候会保留每个集合的支持度，直接淘汰掉子集支持度不满足要求的候选集。</li><li>清理记录使得支持度计算更高效。如果某个项目在 k 的频繁集里面没有出现，那么在 k+1 的频繁集里也不会出现。那这个元素对于后面的支持度计算没有帮助，可以清理掉。</li></ol><p>其他技巧</p><ol><li>2 元素集合技术的特殊技巧</li><li>排除一定满足支持度要求的集合</li><li>同时计算多个频繁模式的支持度</li></ol><h4 id=tree-based-算法>Tree-Based 算法</h4><p>Tree-Based 的算法是以集合枚举的概念出发的，候选项可以从词典树中遍历。频繁集的生成等同于建立词典树。而这类树的生长可以是广度优先也可以是深度优先的。</p><p>每一个结点代表一个物品集，根结点为 null；$I={i_1,\cdots,i_k}$ 的父节点是 ${i_1,\cdots,i_{k-1}}$。</p><p><img src=https://raw.githubusercontent.com/yzlnew/ImageBed/master/blog/2021/02/tree-based.png alt></p><p>值得注意的是 Apriori 也可以被认作是词典树的方法，它使用的是广度优先的策略。</p><h5 id=ais>AIS</h5><p>原始的词典树算法，没有用到特殊的优化方法。参考 Trie 树。</p><h5 id=treeprojection>TreeProjection</h5><p>TreeProjection 可以说是构建词典树的基本框架，有广度优先和深度优先两种。深度优先的方法有更高效的内存管理。</p><p>下面是一个典型的深度优先的 TreeProjection 算法。算法会不断递归扩展前缀的长度，并且只保留和前缀相关的数据。</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>提示</p><p><strong>ExplorePrefix 算法</strong><br><strong>输入</strong>：数据库 $T$，最小支持度 $s$，当前前缀 $P$<br>计算 $T$ 中 1 元素的支持度<br>去除不频繁的元素<br>对于 $T$ 中所有的频繁 $i$<br>->把 $P+i$ 加入到频繁模式集中<br>->从 $T$ 中所有含 $i$ 的数据中构造数据库 $T_i$<br>->去除 $T_i$ 中词典顺序不大于 i 的所有元素<br>->ExplorePrefix($T_i$,$s$,$P \cup {i}$)</p></div><h5 id=vertical-mining>Vertical Mining</h5><p>基本想法是通过反向列表来表示数据库，从而加快计数。</p><table><thead><tr><th style=text-align:left>Item</th><th style=text-align:left>tidlist</th></tr></thead><tbody><tr><td style=text-align:left>a</td><td style=text-align:left>1,2,3</td></tr><tr><td style=text-align:left>b</td><td style=text-align:left>1,2,4</td></tr><tr><td style=text-align:left>c</td><td style=text-align:left>1,2</td></tr></tbody></table><p>算法变种：</p><ol><li>Eclat</li><li>VIPER</li></ol><p>如图找到各个长度为 1 项目的 tidlist，得到频繁项目，然后通过组合已有频繁项目得到新的集合的 tidlist，以此类推。</p><h4 id=基于后缀的递归算法>基于后缀的递归算法</h4><p>不同于前面两类基于前缀的方法，基于后缀的算法通过后缀来扩展频繁模式。</p><h5 id=fp-growth>FP-growth</h5><p>具体如何构建 FPT 并通过其生成频繁参考<a href=https://www.cnblogs.com/pinard/p/6307064.html>这篇博文</a>。</p><p>以下是从 FPT 中构建条件模式基并生成频繁项的过程。FP-growth 的方法只需要扫描两次数据库。</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>提示</p><p><strong>FP-growth 算法</strong><br><strong>输入</strong>：FP-Tree $FPT$，当前后缀 $P$，最小支持度 $s$<br>如果 $FPT$ 是空或者单路径<br>->对于每条路径中结点的组合 $C$，上报所有的 $C\cup P$ 为频繁项<br>否则<br>->对于 $FPT$ 中每一个 $i$<br>&mdash;>$P_i={i}\cup P$<br>&mdash;>上报 $P_i$ 为频繁项<br>&mdash;>从前缀路径中移除不频繁的元素，构建 $FPT_i$<br>&mdash;>if $FPT_i$ 不为空<br>&mdash;&mdash;->FP-growth($FPT_i$,$P_i$,s)</p></div><h5 id=各种变种算法>各种变种算法</h5><ol><li>CT-PRO</li><li>H-Mine</li></ol><h4 id=其他优化方法>其他优化方法</h4><ol><li>Row Enumeration</li><li>Pincer-Search</li></ol><h3 id=参考>参考</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Frequent Pattern Mining, Ed. Charu Aggarwal and Jiawei Han, Springer, 2014.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>What is Frequent Pattern Mining (Association) and How Does it Support Business Analysis?&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Direct Hashing and Pruning&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div id=utter-container></div><script src=https://utteranc.es/client.js repo=yzlnew/yzlnew.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div><div class="footer wrapper"><div class=social-links><ul class=social-media-list><li><a href=mailto:yzlnew@gmail.com title=Mail><i data-feather=mail></i></a></li><li><a href=https://github.com/yzlnew title=Github><i data-feather=github></i></a></li><li><a href=https://t.me/r0brew title=Telegram><i data-feather=message-square></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li></ul></div><nav class=copyright><div>2021 © Copyright Ye Zhiling</div></nav></div><script>feather.replace()</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css integrity=sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js integrity=sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js integrity=sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></body></html>